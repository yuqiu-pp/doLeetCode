package com.leet.code;


import org.omg.PortableInterceptor.INACTIVE;
import sun.security.util.Length;

import java.security.PublicKey;
import java.util.*;

public class SolutionDFS {

    public TreeNode createTreeByArray(Integer[] a, int index){
        int len = a.length;

        // 初始化二叉树，用数组存储
        // 创建当前节点
        TreeNode node = null;

        // root放index=0
        // 左子树节点在数组中的位置  2*i+1
        // 右子树  2*i+2
        if (index < len && a[index]!=null) {
            node = new TreeNode(a[index]);
            // 创建左节点
            node.left = createTreeByArray(a, 2 * index + 1);
            // 创建右节点
            node.right = createTreeByArray(a, 2 * index + 2);
        }

        return node;
    }

    // LeetCode 104

    /**
     *  执行用时 : 1 ms, 在Maximum Depth of Binary Tree的Java提交中击败了90.38% 的用户
        内存消耗 : 36.5 MB, 在Maximum Depth of Binary Tree的Java提交中击败了67.29% 的用户
     */
    // maxDepth = max(left, right) + 1
    public int maxDepth(TreeNode root) {
        if (root == null){
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);

        return 1 + Math.max(left, right);
    }



    // LeetCode 802


    // 任意一点到终点，无环的节点
    // 深度遍历，有环路径的点删除，最后剩余的是解
    public List<Integer> eventualSafeNodes1(int[][] graph) {
        // 统计出度
        int len = graph.length;
        HashMap<Integer, Integer> map = new HashMap<>(len);
        for (int i = 0; i < len; i++) {
            map.put(i, 1);
        }

        // 检测任意一点到终点，有环的路径，从哈希表删除路径上的点
        for (int i = 0; i < len; i++) {
            HashMap<Integer, Integer> visited = new HashMap<>();
            Stack<Integer> path = new Stack<>();
            visited.put(i, 1);
            path.push(i);
            dfs(i, graph, visited, map, path);
        }

        List<Integer> rst = new ArrayList<>(map.size());
        for (int key : map.keySet()){
            rst.add(key);
        }

        return rst;
    }


    // 任意一点到终点，无环的节点
    // 深度遍历，有环路径的点删除，最后剩余的是解
    public List<Integer> eventualSafeNodes2(int[][] graph) {
        int len = graph.length;
        List<Integer> rst = new ArrayList<>();

        // 统计出度、入度
        int[] inDegree = new int[len];
        int[] outDegree = new int[len];
        // 所有点，不符合时从这里删除
        HashMap<Integer, Integer> map = new HashMap<>(len);
        HashMap<Integer, Integer> mapCopy = new HashMap<>(len);
        for (int i = 0; i < len; i++) {
            outDegree[i] = graph[i].length;
            for (int j : graph[i]){
                inDegree[j] ++;
            }
        }

        // 出度和入度都不为0的点才可能形成环
        for (int i = 0; i < len; i++) {
            // if (inDegree[i] != 0 && outDegree[i] != 0){
            //     map.put(i, 1);
            //     mapCopy.put(i, 1);
            // }else {
            //     rst.add(i);
            // }
            if (outDegree[i] == 0){
                rst.add(i);
            }else {
                map.put(i, 1);
                mapCopy.put(i, 1);
            }

        }

        // 检测hash表中任意一点到终点，有环的路径，从哈希表删除路径上的点
        for (int key : mapCopy.keySet()) {
            HashMap<Integer, Integer> visited = new HashMap<>();
            Stack<Integer> path = new Stack<>();
            visited.put(key, 1);
            path.push(key);
            dfs(key, graph, visited, map, path);
        }

        for (int key : map.keySet()){
            rst.add(key);
        }

        return rst;
    }


    public List<Integer> eventualSafeNodes(int[][] graph) {
        int len = graph.length;
        List<Integer> rst = new ArrayList<>();

        // 逆邻接表
        LinkedList<Integer>[] reverseGraph = new LinkedList[len];
        for (int i = 0; i < len; i++) {
            reverseGraph[i] = new LinkedList<>();
        }
        // 0 [1,2]
        for (int i = 0; i < len; i++) {
            for (int j : graph[i]){
                reverseGraph[j].add(i);
            }
        }

        // 统计出度、入度
        int[] inDegree = new int[len];
        int[] outDegree = new int[len];
        // 所有点，不符合时从这里删除
        HashMap<Integer, Integer> map = new HashMap<>(len);
        HashMap<Integer, Integer> mapCopy = new HashMap<>(len);
        for (int i = 0; i < len; i++) {
            outDegree[i] = graph[i].length;
            for (int j : graph[i]){
                inDegree[j] ++;
            }
            map.put(i, 1);
            mapCopy.put(i, 1);
        }

        // 出度和入度都不为0的点才可能形成环
        while (true){
            int num = 0;
            for (int i : map.keySet()){
                if (outDegree[i] != 0){
                    // map.put(i, 1);
                }else {
                    rst.add(i);
                    mapCopy.remove(i);
                    num ++;
                    // 出度为0，逆邻接表查找相关点，出度减1
                    // if (outDegree[i] == 0){
                        for (int n : reverseGraph[i]){
                            if (outDegree[n] > 0){
                                outDegree[n] --;
                            }
                        }
                    // }
                    // 入度为0，邻接表查点，入度减1
                    // if (inDegree[i] == 0){
                    //     for (int n : graph[i]){
                    //         if (inDegree[n] > 0)
                    //         {
                    //             inDegree[n] --;
                    //         }
                    //     }
                    // }
                }
            }

            // 没有出度或入度为0的点
            if (num == 0){
                break;
            }
            if (mapCopy.size() == 0){
                break;
            }
            // map.clear();
            map = (HashMap<Integer, Integer>) mapCopy.clone();
            break;
        }

        // 检测hash表中任意一点到终点，有环的路径，从哈希表删除路径上的点
        for (int key : mapCopy.keySet()) {
            HashMap<Integer, Integer> visited = new HashMap<>();
            Stack<Integer> path = new Stack<>();
            visited.put(key, 1);
            path.push(key);
            dfs(key, graph, visited, map, path);
        }

        for (int key : map.keySet()){
            rst.add(key);
        }

        return rst;
    }



    public void dfs(Integer node, int[][] graph, HashMap<Integer,Integer> visited, HashMap<Integer, Integer> map, Stack<Integer> path){
        if (graph[node] == null){
            visited.remove(path.pop());
            return;
        }

        for (int i : graph[node]){
            // 环
            if (visited.containsKey(i)){
                for (int key : visited.keySet()){
                    map.remove(key);
                }
                return;
            }else {
                visited.put(i, 1);
                path.push(i);
            }
            dfs(i, graph, visited, map, path);
        }
        visited.remove(path.pop());
    }


    public static void main(String[] args) {
        SolutionDFS solution = new SolutionDFS();

        // Integer[] B = {3,9,20,null,null,15,7};
        // TreeNode root = solution.createTreeByArray(B, 0);
        // int n = solution.maxDepth(root);
        // System.out.println(n);

        // int[][] graph = {{1,2},{2,3},{5},{0},{5},{},{}};
        int[][] graph =
                {{214,430},{59},{},{216,230,269,339,493},{59},{94,138,394,431},{156},{325,398,450},{},{267,313,335,425,454,475},{109,145,166,345,427,468},{104,108,193,337,452},{329,365,417,432,488},{91,316,377,378,389},{102,161,308,448,452},{32,76,171,385,415,432},{},{42,158,227},{407,493},{64,463},{261,323},{76},{150,471},{39,67,109,406},{80,283,377,400,487},{66,184,288,307,466},{33},{},{120,277,278},{164,250,271,276,459},{358},{80,183,196,224,225},{258,267,274,476},{92,98,427},{179,280},{},{174,264,437,448},{78,220,356,403,478,484},{96,150,263,343,428},{50,204,248,429,458},{57,61,83,193,415,429},{46,161,227,267,401,482},{370},{301},{298,337,474},{49,67,187,218,353},{65,88,262,406},{227,294,310},{160,168,336},{374},{},{59,252,400,408,439,476},{177,332},{122,212,294,465},{65,92,365},{},{250,304},{142,207},{116,125,386},{},{131,141,204},{71,88,96,478},{},{95},{189},{92,125,315,334,463},{112},{},{},{182,252,358,416,457},{109},{93,142,158,168,300},{40,180,305},{309,390},{87,129,325,362,401,466},{135,225,242,318},{194,275,408},{},{152,302,359,399,427,438},{},{42,379,397},{114,317,351,456},{214,237},{87,114,216,241,267,472},{91,111,273,446},{65,278,309},{},{112,167,352,361,423},{173,193,213,276,390},{154,276,422,433},{286,337,354,448,481},{121,244,335,469},{46,276,328},{292,295,325,350,455},{218,497},{136,145,288,338,410,494},{133,167,214,486},{},{114,196,199,339,417},{220,266,349,360,382,493},{},{84,119,422,463},{339,437},{},{279,434,443,486},{172,211,230,318,457},{28},{233,430,454},{152,248,301,319,428},{115,206,216},{212,402},{},{148,224,253,408,409,485},{},{125,173,304},{142,236,295,377,471},{273,342,392,416,460},{},{208},{207},{},{158,225,426},{154,376,408,413,477},{126,137,193,253,387},{},{388},{149,321,327,381},{147,260,292,321,421},{163,200,206,240,422},{233,333,350,374,433},{},{183,242,393},{157,229,346,406,471},{182,218,290,292,375},{182,389,431,480},{164,231,435},{161,166,287,360,384},{165,198,217,228,249,437},{145,158,233,246,379},{201,320,338,403,409,446},{211,221,377},{248,409,416,439,447},{414},{61,162,220,260,267,410,441},{147,225,269,353,430,454},{196,256,299,344,374,492},{221,315,478},{},{210,273,348,421,429},{164,285,316,445},{161,381,407},{299,311,337,418},{407},{231},{},{168,265,296,334,346,441},{185,260,480},{204,469},{185,262,299,476},{337,363,433},{210,235,390,461,490},{206},{},{},{},{},{419,461},{227,231,264,351,383},{181,194,213,235,304,396},{221,252},{225,319,356,370},{181,324,415},{248},{382},{268},{243},{89,198,212,232,246,459,494},{264,402,418,423},{368,479},{279},{96,275,301,321,353,357},{372},{206,471},{188,209,214,231,402,436},{185,189,385,414,427},{260,306,323,365,436,475},{270,320,494},{},{435},{194,306,345,368,474},{375,424},{205,220,365,378,438,492},{209,348,403,455},{221,305,353,450},{},{205,256,452},{199,211,325,435,490},{234,278,326,435},{255,410,446},{296,311,418,494},{274,275,295,359,413,452},{228,277,330,371,399,489},{206,490},{},{420},{},{203,334},{219,360,404},{355},{333,458},{},{397,442,446},{},{236,302,309,408,450,455},{315},{430},{308,334,352,377,421,444},{230,281,325,329,350,368},{329,352,371,451,493},{239,320,362,396,408},{},{261,370},{223,251,272,282,461},{343,366,395,448,466,489},{378,470,493},{289,290},{},{255,262,290,366,448},{276,299,434,487},{267,270},{239,250,302,349,460,478},{238,319,336,419,482,495},{358,435,495},{258,263,271,383,479},{207,390},{335,369,376,383,389,463},{323,407,447,452,456},{377},{331,375,421,424},{293,351,352},{324,403},{},{480},{},{303},{261,370,392,441},{290,298,395,405,431,492},{316,353,450,451,475},{258,259,260,308,343,436},{282,314,359,380,429,483},{420,463},{258,265,340,360,384,391},{268},{374},{282,311},{336},{},{443},{442},{333,362,491},{275,277,390,451,475},{355},{265,355,356,359,431,491},{289,290,432,449},{272,333,339,369,419,422},{348,414},{277,324,459,497},{271,298,422},{},{282,326,345,388},{310,406,451},{292,298,421},{288,333,357,359,421,439},{292,348,409,460},{347,352,361,381,435},{473},{389,407,423,477},{317,349,374,400,406,408},{58,373,392,442,497},{288,492},{401,428,468},{295,372,420,454,462},{302,306,337,368,390,495},{335,339},{},{316,379},{302,333,387,404,412,454},{302,328,455,464,490},{326,372,463,469},{},{306,314,414},{307,323,448,468,477,489},{437,459},{379,392,404,435,449,468},{348,395,397,451,455},{302,379,407,409,418},{455},{416},{418,450},{333},{},{324,334,417,418},{313,391,474},{466},{378,392,399,438},{363,373,453,455},{317,341,396,431,460},{357},{414,428},{323,450},{356,373,374,449},{442,452},{406},{},{456},{},{348,383,447,467},{341,374,420,475},{341,392,410,446},{},{321,347,370,465,497},{},{},{406},{461},{403,479},{448},{57,402,416,447,467},{397,443,445,473},{235,385,449},{357,359,379,432,443},{431,481,496},{339,343,354,388,399,422},{381,399},{355,456,457},{339,465,482},{393},{415},{395,467,493,499},{},{},{362,364,493},{},{393,474},{360,452},{390,483},{241,350,470},{400,499},{364,376,488,498},{380,382,499},{358,381,496},{},{},{443},{457,459,465},{158,401,427,433,470},{380,451},{},{364,390,391,421,436,486},{},{370,393,417,464,480,491},{109,402,416,430},{403},{365,372,404,422,458},{431,492},{388,410,414,461,486},{},{407,430,435},{377,417,428,482},{390,396,420,441},{375,401,416,444,462,463},{423,478},{},{},{383,401,427,453,494},{455,473,495},{437,441,450,468,471,489},{385,430,472,475,491,497},{381,397,414,452,485},{427,443,451,457,481,492},{},{394,407,442,461,472},{},{423,434,447,475,485,491},{},{},{414,419,466},{434,467,469,487,494,495},{399,452,463,468,470},{407,430,441,442,496},{392,393,439,445,471},{},{396,407,446,447,475},{},{397,483},{419,430,456,457,464},{457},{416,424,430,435,477,497},{410,435,438,474,478},{417,438,444,449,472,499},{435,447,469,489},{435,461,488},{447},{424,442,460,470,486},{411,413,439,480,483},{424,444},{429,434,438},{},{},{472,473,497},{412,418,425,479},{460,486,490},{423,427,448},{419,465,474,479,485},{490,492},{451,481,499},{442,478},{461,480},{438,457,464,478,484,496},{450,457,466,489},{},{},{427,447,448,463,478,498},{},{437,441,451,455,489},{435,477,492},{446,450},{437},{461,466},{436,443,469,470,487,499},{},{469,475},{457,477,481},{437,476,482,491,492},{448,456,462,465,476},{436,438,449,454,477,496},{450,462,484},{445,447,453,474,485},{474},{471,475,477,490,493},{445,489,495},{442},{},{},{446,451,454,459,482,497},{469,475,492,498},{450,460,464,499},{460,462,463,485,495},{},{497},{464,480,490,493,498},{462,463,465,479,489},{465,469},{459,460,464,470,474,486},{455,485,491,494},{478},{462,463,468,479,484,491},{466,468,477,478,492},{461,475,476},{482,495},{463,481,483,485},{462,471,477,491,493},{468,470,473,475,496,497},{483},{468,490},{479,480},{471,475,478,495},{470,473,476,495},{469,474,483,484,492,494},{471,476,477,486,495,496},{481,485,499},{477,479,486,489},{473,475,488,493,497},{485,488,492},{475,479},{487,494,498},{482},{480,490,493,494,495,497},{479,494},{},{482,490,491,492,493,496},{484,495},{},{487,490,491,493,496,499},{485,487,499},{490,496,497},{},{},{},{494},{492,494,495,498},{492,494,495,497,498},{493,494,495,496,497,498},{494,495,496,497,498,499},{496,497,498,499},{},{498},{175,498,499},{499},{}};
        List<Integer> rst = solution.eventualSafeNodes(graph);
        for (Integer i : rst){
            System.out.print(i + ",");
        }
    }
}
